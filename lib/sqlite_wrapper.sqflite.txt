library sqlite_wrapper;

// ignore: depend_on_referenced_packages

import 'dart:async';

import 'package:flutter/material.dart';
import 'package:sqflite_common/sqlite_api.dart';
import 'package:sqflite_common_ffi/sqflite_ffi.dart';

typedef FromMap = dynamic Function(Map<String, dynamic> map);

class StreamInfo {
  String sql;
  List<String> tables;
  StreamController controller;
  List<Object?>? params;
  FromMap? fromMap;
  bool singleResult;
  StreamInfo(
      {required this.sql,
      required this.tables,
      required this.controller,
      this.params,
      this.fromMap,
      this.singleResult = false});
}

class SQFLiteWrapper {
  static final SQFLiteWrapper _singleton = SQFLiteWrapper._internal();
  static final List<StreamInfo> streams = [];
  late Database _db;

  factory SQFLiteWrapper() {
    return _singleton;
  }

  SQFLiteWrapper._internal();

  Future<void> openDB(String path, {OpenDatabaseOptions? options}) async {
    _db = await databaseFactoryFfi.openDatabase(path, options: options);
  }

  Future<void> closeDB() {
    return _db.close();
  }

  /// Database accessible from outside (map the internal _db variable)
  get database {
    return _db;
  }

  /// Executes an SQL Query with no return value
  /// params - an optional list of parameters to pass to the query
  /// tables - an optional list of tables affected by the query
  Future<dynamic> execute(String sql,
      {List<String>? tables, List<Object?>? params}) {
    final String sqlCommand = sql.substring(0, sql.indexOf(" ")).toUpperCase();
    switch (sqlCommand) {
      case "INSERT":
        // Return the ID of last inserted row
        final res = _db.rawInsert(sql, params);
        _updateStreams(tables);
        return res;
      case "UPDATE":
        // Return number of changes made
        final res = _db.rawUpdate(sql, params);
        _updateStreams(tables);
        return res;
      case "DELETE":
        // Return number of changes made
        final res = _db.rawDelete(sql, params);
        _updateStreams(tables);
        return res;
      default:
        return _db.execute(sql, params);
    }
  }

  /// Executes an SQL Query that return a single value
  /// params - an optional list of parameters to pass to the query
  /// fromMap - a function that convert the result map to the returned object
  /// singleResult - return an object instead of a list of objects
  Future<dynamic> query(String sql,
      {List<Object?>? params,
      FromMap? fromMap,
      bool singleResult = false}) async {
    List<Map> results = await _db.rawQuery(sql, params);
    if (singleResult) {
      if (results.isEmpty) {
        return null;
      }
      // Single results
      Map<String, dynamic> result = results.first as Map<String, dynamic>;
      // If only a column has been extracted return the simple object
      if (result.keys.length == 1) {
        return result[result.keys.first];
      }
      if (fromMap != null) {
        // The fromMap method converts the Map to the returned object
        try {
          final map = result;
          //  _rowToMap(result);
          return fromMap(map);
        } catch (error) {
          debugPrint(error.toString());
        }
      }
      return result;
    }
    // Multiple results
    // Return just a simple field object
    if (results.isNotEmpty && results.first.keys.length == 1) {
      final String onlyField = results.first.keys.first;
      return results.map((e) => e[onlyField]).toList();
    }
    if (fromMap != null) {
      return results
          .map((map) => fromMap(map as Map<String, dynamic>))
          .toList();
    }
    // Return a list of Map
    return results;
  }

  Future<dynamic> update(Map<String, dynamic> map, String table,
      {required List<String> keys}) async {
    //VALUES
    String updateClause = "";
    List params = [];
    final values = map.keys.where((element) => !keys.contains(element));
    for (String value in values) {
      if (updateClause.isNotEmpty) updateClause += ", ";
      updateClause += "$value=?";
      params.add(map[value]);
    }
    // KEYS
    String whereClause = "";
    for (String key in keys) {
      if (whereClause.isNotEmpty) whereClause += ", ";
      whereClause += "$key=?";
      params.add(map[key]);
    }

    String sql = "UPDATE $table SET $updateClause WHERE $whereClause";
    return execute(sql, tables: [table], params: params);
  }

  /// Insert a new record in the passed table based on the map object
  /// and return the new id
  Future<dynamic> insert(Map<String, dynamic> map, String table) async {
    //VALUES
    String insertClause = "";
    String insertValues = "";
    List params = [];

    for (String value in map.keys) {
      if (insertClause.isNotEmpty) {
        insertClause += ", ";
        insertValues += ", ";
      }
      insertClause += value;
      insertValues += "?";
      params.add(map[value]);
    }
    String sql = "INSERT INTO $table ($insertClause) VALUES ($insertValues)";
    return execute(sql, tables: [table], params: params);
  }

  /// Executes an SQL Query that return a single value
  /// params - an optional list of parameters to pass to the query
  /// fromMap - a function that convert the result map to the returned object
  /// singleResult - return an object instead of a list of objects
  Future<Stream> watch(String sql,
      {List<Object?>? params,
      FromMap? fromMap,
      bool singleResult = false,
      required List<String> tables}) async {
    StreamController sc = StreamController();
    // Initial values
    final StreamInfo streamInfo = StreamInfo(
        controller: sc,
        sql: sql,
        tables: tables,
        params: params,
        singleResult: singleResult);
    streams.add(streamInfo);
    await _updateStream(streamInfo);
    //Future.delayed(
    //    const Duration(seconds: 10), (() => _updateStream(streamInfo)));

    return sc.stream;
  }

  /// Reload data in stream emitting the new result
  _updateStream(StreamInfo streamInfo) async {
    dynamic results = await query(streamInfo.sql,
        params: streamInfo.params, singleResult: streamInfo.singleResult);
    streamInfo.controller.add(results);
  }

  /// Update all the streams connected to one of the table in the list
  _updateStreams(List<String>? tables) {
    if (tables == null || tables.isEmpty) return;
    for (StreamInfo s in streams) {
      for (String table in tables) {
        if (s.tables.contains(table)) {
          _updateStream(s);
          continue;
        }
      }
    }
  }
}
